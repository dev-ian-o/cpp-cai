<?php
function code($val){
    echo "<code><pre>".$val."</code></pre>";
}
?>
<h3>
    <strong>Chapter 5.3 Programmer-Defined Classes and Objects</strong>
</h3>

<p class="mL15">

    In object-oriented programming, we view an application as a system of interacting <a name="ch10term1"></a><strong>objects</strong>. Each object is
    responsible for its own actions. The objects interact by sending messages to one another and behaving in certain ways in response to the messages. A
    message may be accompanied by one or more pieces of data, which might be needed for the object to carry out the action. When an object receives a message,
    it is the object's responsibility to carry out the action using some method.
</p>
<p class="mL10">
    <b>5.3.1 The Structure of a Program that Uses Classes</b>
</p>
<div class="mL15">
<p>
    In general, we will use the following outline for all our simple programs that use classes in this section.
</p>
<p>
    <a name="ch11note07"></a>
    We shall use the following program structure: (for simple programs that use classes)
</p>
<p>
    //Preprocessor directives
</p>
<p>
    //Class declarations
</p>
<p>
    //Method definitions
</p>
<p>
    //Definition of main()
</p>
<p>
    We emphasize that program structure applies to simple programs. For more complex programs we can divide the program code into several files, one file
    containing main() and the others each containing one class definition. After compiling the source files, the linker combines the object files into one
    executable program. For now, however, we shall stay with the simple program structure described.
</p>
</div>
<p class="mL10">
   <b> 5.3.2. Defining a Class</b>
</p>
<div class="mL15">
<p>
    Classes are defined using either keyword class or keyword struct, with the following syntax:
</p>
<pre><code>
class Class_Name {
  access_specifier_1:
    member1;
  access_specifier_2:
    member2;
  ... 
  public class method declarations;
  public class method declaration and definition;
  ... 

} <object_names>;

public class method definitions for class methods that are only declared inside the class

</code></pre>
<p>
    <br/>
    Where class_name is a valid identifier for the class, object_names is an <em>optional</em> list of names for objects of this class. The body of the
    declaration can contain <em>members</em>, which can either be data or function declarations, and optionally <em>access specifiers</em>.
    <br/>
    <br/>
</p>
<p>
    <strong>Note: Coding Guidelines</strong>
</p>
<p>
    · Think of an appropriate name for your class. Don't just call your class XYZ or any random names you can think of.
</p>
<p>
    · Class names should start with a CAPITAL letter. If a class is a two word name, capitalize the first letter of each word and use underscore to connect
    them.
</p>
<p>
    For example:
</p>
<div class="row">
    <div class="col-xs-6">
        <pre class="mL50"><code>
class Triangle {
  access_specifier_1:
    member1;
  access_specifier_2:
    member2;
  ...
} <object_names>;
        </code></pre>
    </div>
    <div class="col-xs-6">
        <pre class="mR50"><code>
class Student_Record {
  access_specifier_1:
    member1;
  access_specifier_2:
    member2;
  ...
} <object_names>;
        </code></pre>
    </div>
</div>
<p>
    <strong>Note</strong>
    : object_name is optional when creating the class.
</p>
<p>
    <br/>
Classes have the same format as plain <em>data structures</em>, except that they can also include functions and have these new things called    <em>access specifiers</em>. An <em>access specifier</em> is one of the following three keywords: private, public or protected. These specifiers modify the
    access rights for the members that follow them:
</p>
<ul type="disc">
    <li>
        private members of a class are accessible only from within other members of the same class (or from their<em>"friends"</em>).
    </li>
    <li>
        protected members are accessible from other members of the same class (or from their <em>"friends"</em>), but also from members of their derived
        classes.
    </li>
    <li>
        Finally, public members are accessible from anywhere where the object is visible.
    </li>
</ul>
<p>
    <br/>
    By default, all members of a class declared with the class keyword have private access for all its members. Therefore, any member that is declared before
    any other <em>access specifier</em> has private access automatically.
</p>
<p>
    5.3.3 <strong>Declaring Class Members</strong>
</p>
<p>
    A class contains <em>class members</em> as mentioned in defining the class., which can either be data(known as attribute) or function declarations (can be
    any of the following: constructor method, accessor method or mutator method). The following is the syntax on how we declare a class members:
</p>
<p>
    Syntax for declaring <strong>instance variable</strong> (one of the class members) of a class, usually have a <strong>private</strong> access specifier.
</p>
<pre><code><access specifier> :
        <type> <attribute name>;</code></pre>
<p>
    Or
</p>
<p>
    Syntax for declaring <strong>class method (another class member)</strong>, usually have a <strong>public</strong> access specifier.
</p>

<pre><code><access specifier> :
    <type> <class method name>(<optional argument list>);
    <type> <class method name>(<optional argument list>)
        {  
          Method definition…
        };
</code></pre>

<p>
    <strong>Note: Coding Guidelines</strong>
</p>
<p>
    · Declare all your class members (instance variables) on the top of the class declaration.
</p>
<p>
    · Declare one variable for each line.
</p>
<p>
    · Class Members (instance variables), like any other variables should start with a SMALL letter.
</p>
<p>
    · Use an appropriate data type for each variable you declare.
</p>
<p>
    · Declare class members (instance variables) as private so that only class methods can access them directly.
</p>
<p>
    For example:
</p>
<div class="row">
    <div class="col-xs-6">
        <pre class="mL80"><code>
class Triangle{
  private:
    int base;
    int height;
  public:
    Triangle();
    void set_base(int);
    int get_base();
    int area();
};

        </code></pre>
    </div>
    <div class="col-xs-6">
        <pre class="mR80"><code>
class Student_Record {
  private:
    string stud_no;
    string stud_name;
    int units_enrolled;
    double rate_per_unit;
  public:
    Student_Record();
    double compute_tfee();
};

        </code></pre>
    </div>
     <div class="col-xs-12 ">
    <pre class="mL80 mR80"><code>
Note: <i>base</i> and <i>height</i> are the <b>private class members</b> for class <i>Triangle</i> and <i>stud_no</i>, <i>stud_name</i>,<i>units_enrolled</i> while <i>rate_per_unit</i> are <b>private class members</b> for class <b>Student_Record</b>.  
<b>
Triangle(), set_base(), get_base() and area() are the public class members for the class Triangle while Student_Record() and compute_tfee() are the public class members for the class Student_Record.
<br>
Public class members (usually class methods) will be more elaborated on the next discussion.
</b></code></pre>
    </div>
</div>
</div>
<p class="mL10"><b>5.3.4 Declaring Objects</b></p>
<div class="mL15">
<p>Defining a class does not create any actual objects.  A class is just an abstract descriptions of what an object will be like if any objects are ever actually instantiated.  
<br>
Like the discussion in string to declare a string object is:
</p>
<p class="text-center"><pre><code>string str;</code></pre></p>
<i>where:</i>
<ul>
    <li>string is a built-in class in C++</li>
    <li>str is an object declared out of the string class</li>
</ul>
<p>Therefore, the syntax in declaring objects out of the user-defined class is</p>
<p class="text-center"><pre><code><user-define class_name> <object_names>;</code></pre></p>
<p>For example, using the Triangle class, we can declare object as</p>

<p class="text-center"><pre><code>Triangle triA;
Triangle triB;
</code></pre></p>
<p>We can also declare objects upon defining the class by specifying the object_names (list by comma if more than one) like,</p>
<p><pre><code>class Triangle{
  private:
    int base;
    int height;
  public:
    Triangle();
    void set_base(int b);
    int get_base();
    int area();
}triA,triB;
</code></pre></p>
<p>
    <strong>Wherein, objects triA and TriB are created(declared) upon defining the class Triangle.</strong>
</p>

<p>
    Note:
</p>
<p>
    · We can declare object inside the main or upon defining the class itself.
</p>
</div>
<p class="mL10">
    <strong>5.3.5 Class Methods</strong>
</p>
<div class="mL15">
<p>
    A <strong>class method</strong> (also known as member function) of a class is a function that has its definition or its prototype within the class
    definition like any other variable. It operates on any object of the class of which it is a member, and has access to all the members of a class for that
    object.
</p>
<p>
    It is very important to remember that class methods have access to all the instance variables of the class. There is no need to declare the class instance
    variables inside a class method just use the instance variables in the method.
</p>
<p>
    All class methods including constructor (to be discussed later) must be declared inside the definition of the class before it can be defined outside the
class definition (declaration). And any method that is defined outside the class declaration must use the <a name="ch11term14"></a>    <strong>scope resolution operator, </strong>
    <tt>
        <strong>::</strong>
    </tt>
    , in its method definition header as follows:
</p>
<pre>return-type ClassName::MethodName(parameter-list)</pre>
<p>
    Read the operator
    <tt>
        ::
    </tt>
    as the possessive "'s". For example, read the definition header of set_values() of the Triangle class as “Triangle’s set_values()”.
</p>
<p>
    For example, we have a class definition such as,
</p>
<pre><code>class Triangle{
  private:
    int base;
    int height;
  public:
    void set_base(int b);
    int get_base();
    int area();
}triA,triB;</code></pre>
<p>
    Where <strong>set_base(int), get_base() and area()</strong> are class methods for the class Triangle.
</p>
<p>
    Therefore we should have the definition of the class methods <strong>set_base(int), get_base() and area() </strong>outeside the class definition using the
    scope resolution operator (::), such as,
</p>
<pre><code>class Triangle{
  private:
    int base;
    int height;
  public:
    //class method declaration
    void set_base(int);
    int get_base();
    int area();
}triA,triB;

//class method definition for set_base(int)
void Triangle::set_base(int b){
    base = b;
}

//class method definition for get_base()
int Triangle::get_base(){
    return base;
}

//class method definition for area()
int Triangle::area(){
    return (base * height) / 2;
}</code></pre>
<p>
    Why is the scope resolution operator necessary? There are situations in which it is necessary to declare several classes. In this case, it is possible that
    two or more of the classes will have methods with the same name. Suppose, for example, that we also declare a
    <tt>
        Cirlce
    </tt>
    class, which also has a
    <tt>
        set_values()
    </tt>
    method. If the
    <tt>
        set_values()
    </tt>
methods of the two classes are defined inside their respective class definitions, there would be no confusion about which method is being    <a name="iddle1332"></a><a name="iddle1330"></a><a name="iddle1326"></a><a name="iddle1264"></a>defined. However, if the methods are defined outside the
    class definitions, as we did for the
    <tt>
        set_values()
    </tt>
    method, then it is necessary to specify to which class each method the
    <tt>
        set_values()
    </tt>
    method belongs. The definition
    <tt>
        Triangle::set_values()
    </tt>
    would be for
    <tt>
        Triangle's set_values()
    </tt>
    method, and the definition
    <tt>
        Circle::set_values()
    </tt>
    would be for
    <tt>
        Circle's set_values()
    </tt>
    method.
</p>
<p>
    For example:
</p>
<div class="row">
    <div class="col-xs-6">
    <pre>Example 1</pre>
<pre><code>class Triangle{
  private:
    int base;
    int height;
  public:
    //class method declaration
    void set_base(int);
    int get_base();
    double area ();
};

//set_base() definition
void Triangle::set_base(int b){
    base = b;
}
//get_base() definition
int Triangle::get_base(){
    base = b;
}

//area() definition
double Triangle::area (){
return (base*height)/2;
}</code></pre>
    </div>
    <div class="col-xs-6">
    <pre>Example 2</pre>
<pre><code>class Circle{
  private:
    int radius;

  public:
    //class method declaration
    void set_values (int);
    double area ();
};

//set_values() definition
void Circle::set_values (int r){
    radius = r;
}


//area() definition
double Circle::area() {
return 3.1416 * (radius * radius);
}
</code></pre>
    </div>
<div class="col-xs-12"><pre><code>NOTE: In both examples, there is <b>set_base()</b>,<b>get_base()</b> and <b>area()</b> class methods for classes Triangle and Circle. Notice that both the set_value() and area() class methods are defined outside the class, this why is the scope resolution operator is necessary. Because we will know who possess’ the method. As in the definition <b>Triangle::set_values()</b> would be for <b>“Triangle's set_values()”</b> method, and the definition <b>Circle::set_values()</b> would be for <b>“Circle's set_values()”</b> method.
</code></pre></div>
    <div class="col-xs-12">
    <pre><code>Example 3</code></pre>
        <pre><code>class Student_Record {
  private:
    string stud_no;
    string stud_name;
    int units_enrolled;
    double rate_per_unit;
  public:
    void set_stud_no(string);
    void set_stud_name(string);
    double compute_tfee(int,double);
}

void Student_Record::set_stud_no(string num){
    stud_no = num;
}

void Student_Record::set_stud_name(string name){
    stud_name = name;
}

double Student_Record::compute_tfee(int units, double rate){
    return units * rate;
}</code></pre>
    </div>
    <div class="col-xs-12"><pre><code>Note:  In this example, the set_studno(), set_stud_name() and compute_tfee() are all Student_Record class method.</code></pre></div>
</div>
</div>
<p class="mL10">
    <strong>5.3.6 Accessing Class Method</strong>
</p>
<div class="mL15">
<p>
    To call a class method( also known as function method) of a particular object we use the <strong>dot (.) member operator.</strong>
</p>
<p>
    Therefore, the syntax for accessing class method, use the following:
</p>
<p>
    <pre><code><object_names><strong>.</strong><class_method></code></pre>
</p>
<p>
    For example:
</p>
<p>
    Assuming we have created an object triA out of the Triangle class, like
</p>
    <pre><code>Triangle triA;</code></pre>
<p>
    And we have a method named set_values() which requires an int argument, get_values() which returns an int and area() that returns double, like
</p>
<pre><code>void set_base(int b){
    base = b;
}

int get_base(){
    return base;
}

double area(){
    return (base * height) / 2;
}
</code></pre>
<p>
    Then to call the class method area() for the object triA, we do the ff
</p>
<pre><code>triA.area();</code></pre>
<p>
    And to call the class method set_base(int)for the object triA, we do the ff
</p>
<pre><code>triA<strong>.</strong>set_base(12);</code></pre>
<p>
    And to call the class method get_base() for the object triA, we do the ff
</p>
<pre><code> triA<strong>.</strong>get_base();</code></pre>
<p>
    the dot(.) member operator is separator for object and method.
</p>
<p>
    <strong>NOTE:</strong>
</p>
<p>
    · A common practice is to define short methods (one or two statements) within the class definition and longer methods outside the class declaration.
</p>
<p>
    · All instance variables of a class are accessible inside all methods of the class. Therefore, you can code a class method as though the class instance
    variables have been declared inside the method definition.
</p>
</div>
<p class="mL10">
    <b>5.3.7 A More Useful Class Accessor and Mutator Methods</b>
</p>
<div class="mL15">
<p>
    A class method is divided into 3 classifications: accessor, mutator and constructor.
</p>
<p>
    <strong>Accessor Method</strong>
</p>
<p>
A method whose only purpose is to access the value of a private instance variable of the class is sometimes called an <strong>accessor method.</strong>    <strong> </strong> The
    <tt>
        get_base()
    </tt>
    in the
    <tt>
        Triangle
    </tt>
    class is an example of an accessor method.
</p>
<p>
    Syntax of defining an accessor method
</p>

<pre><code><return-type>   ClassNiame::<getAccessorMethodName>(){
         <accessor-method-definition>;
         ……
}
</code></pre>
<p>
    For example:
</p>
<?php code("int get_base();");?> 
<p>
    To recall, we have two private int class member in the
    <tt>
        Triangle
    </tt>
    class namely,
    <tt>
        int base;
    </tt>
    and
    <tt>
        int height;
    </tt>
    ,
</p>
<p align="center">
    <img src="../uploads/images/c5-3/AccessorMutator1.png">
</p>
<p>
    Therefore, to include an accessor method to access(retrieve) the value of the private data member base, we should include the accessor method declaration
    inside the class such as,
</p>
<br clear="all"/>
<p class="text-center">
   <img src="../uploads/images/c5-3/Accessor2.png">
</p>
<p>
    Explanation of the example:
</p>
<p>
    <tt>
        ·
    </tt>
    Accessor method name starts with the word
    <tt>
        get
    </tt>
    followed by a name appropriate for the action of the method, such as
    <tt>
        get_base()- (get
    </tt>
    and the data member
    <tt>
        base
    </tt>
    in the
    <tt>
        Triangle
    </tt>
    class
    <tt>
        )
    </tt>
</p>
<p>
    · It have a return-type the same as the data type of the class data member (also known as instance variable).
</p>
<p>
    <tt>
        ·
    </tt>
    The data type of
    <tt>
        base
    </tt>
    data member is
    <tt>
        int,
    </tt>
    that is why the
    <tt>
        get_base()
    </tt>
    accessor method will have a return type of
    <tt>
        int
    </tt>
    . So the complete declaration for the acccessor is
    <tt>
    </tt>
</p>

<?php code("int get_base();")?>

<p>
    And the definition of the accessor method outside the class always has the keyword
    <tt>
        return
    </tt>
    , which returns the data member it represents, for example, the accessor method declaration
    <tt>
        int get_base();
    </tt>
    will have a method definition
</p>
<br clear="all"/>
<p class="text-center">
   <img src="../uploads/images/c5-3/Accessor3.png">
</p>
<p>
    Of course, we have to follow the use of scope resolution operator ::
</p>
<p>
    For more elaboration, for example, we have a private data member in the class such as
</p>
<?php code("string name;
int age;")?>
<p>
    Therefore the accessor method declaration for the name and age data members respectively should be:
</p>
<?php code("//declaration of accessor method for name data member
string get_name(); 
and
//declaration of accessor method for age data member
int get_age();
")?>
<p>
    And the accessor method definition for each will be, <strong>assuming the class name is Sample</strong>:
</p>
<?php code("
//definition of accessor method for  name  data member
string Sample::get_name(){
      return name;     
}

//definition of accessor method for  age data member
int Sample::get_age(){
      return age;
}")?>

<p>
    <strong>Mutator Method</strong>
</p>
<p>

    A method that changes the value or assign a value of an instance variable (data member) is called <strong>mutator method.</strong> <strong> </strong> The
    <tt>
        set_base()
    </tt>
    in the
    <tt>
        Triangle
    </tt>
    class is an example of an mutator method.
</p>
<p>
    Syntax of defining an mutator method
</p>
<?php code("<return-type>   ClassNiame::<setAccessorMethodName>(<data-type> identifier){
         <mutator-method-definition>;
         ……
}
")?>
<p>
    For example:
</p>
<?php code("void set_base(int b);"); ?>
<p>
    To recall, we have two private int class member in the
    <tt>
        Triangle
    </tt>
    class namely,
    <tt>
        int base;
    </tt>
    and
    <tt>
        int height;
    </tt>
    ,
</p>
<p align="center">
   <img src="../uploads/images/c5-3/AccessorMutator1.png">
</p>
<p>
    Therefore, to include an mutator method to change(assign) the value of the private data member base, we should include the mutator method declaration
    inside the class such as,
</p>
<br clear="all"/>
<p align="center">
   <img src="../uploads/images/c5-3/Mutator2.png">
</p>
<p>
    Explanation of the example:
</p>
<p>
    <tt>
        ·
    </tt>
    Mutator method name starts with the word
    <tt>
        set
    </tt>
    followed by a name appropriate for the action of the method, such as
    <tt>
        set_base()- (set
    </tt>
    and the data member
    <tt>
        base
    </tt>
    in the
    <tt>
        Triangle
    </tt>
    class
    <tt>
        )
    </tt>
</p>
<ul>
    <li>
        The return-type is always
        <tt>
            void
        </tt>
        . The data-type of the argument should be the same data-type of the class data member (also known as instance variable).
    </li>
    <li>
        The data type of
        <tt>
            base
        </tt>
        data member is
        <tt>
            int,
        </tt>
        that is why the data-type of the argument in
        <tt>
            set_base()
        </tt>
        mutator method should be
        <tt>
            int
        </tt>
        followed by any identifier that will accept the data you will pass. So the complete declaration for the mutator is
    </li>
</ul>
<?php code("void set_base(int b);");?>
<p>
    And the definition of the mutator method outside the class always assigns the value pass to the argument to data member in the class, for example, the
    method method declaration
    <tt>
        void set_base(int b);
    </tt>
    will have a method definition
</p>
<p align="center">
   <img src="../uploads/images/c5-3/Mutator3.png">
</p>
<p>
    Of course, we have to follow the use of scope resolution operator ::
</p>
<p>
    For more elaboration, for example, we have a private data member in the class such as
</p>
<?php code("string name;
int age;");?>
<p>
    Therefore the mutator method declaration for the name and age data members respectively should be:
</p>
<?php code("//declaration of mutator method for name data member
void set_name(string n); 
and
//declaration of mutator method for age data member
void set_age(int a);
;
");?>
                    
                    
                    
<p>
    And the mutator method definition for each will be, <strong>assuming the class name is Sample</strong>:
</p>
<?php code("//definition of mutator method for  name  data member
void Sample::set_name(string n){
      name=n;     
}

//definition of mutator method for  age data member
void Sample::set_age(int a){
      age=a;
}");?>
</div>
<p class="mL10">
    5.3.<strong>7. The Class Constructor</strong>
</p>
<div class="mL15">
<p>
    What would happen in <em>Triangle</em> class if we called the member function <code>area</code> before having called <code>set_values</code>? An
    undetermined result, since the members <code>base</code> and <code>height</code> had never been assigned a value.
</p>
<p>
    In order to avoid that, a class can include a special function called its <em>constructor</em>, which is automatically called whenever a new object of this
    class is created, allowing the class to initialize member variables or allocate storage.
</p>
<p>
    A <em>constructor</em> is a class method that automatically executes when an object of that class is instantiated. The name of the constructor must be the
    same as the name of the class and the constructor cannot have a return type (because it always results in creating a class object). If a constructor is not
    explicitly declared in the class definition, by default, C++ provides the <a name="ch11term19"></a><strong>default constructor</strong>. The default
    constructor only creates the object it <strong><em>does not</em></strong> initialize the object's data members.
</p>
<p>
    The scope resolution operator (<strong>::</strong>) must be used in the definition of the constructor because the definition is outside the class
    declaration.
</p>
<p>
    Remember that constructors are important in instantiating an object as we discuss it in the previous lesson (string Class: Introduction to Classes and
    Objects) . It is a function (method) where all the initializations are placed.
</p>
<p>
    Again the, the following are the properties of a constructor:
</p>
<ul>
    <li>
        <strong>Constructors have the same name as the class</strong>
    </li>
    <li>
        <strong>
            A constructor is just like an ordinary function(method), however only the following information can be placed in the header of the constructor,
        </strong>
    </li>
    <li>
        <strong>Constructors does not have any return value</strong>
    </li>
</ul>
<p>
    If we have a class definition, such as,
</p>
<?php code("class Triangle{
  private:
    int base;
    int height;
  public:
    //class method declaration
    void set_values (int,int);
    double area ();
};
");?>

<p>
    The constructor name will be
</p>
<?php code("Triangle()");?>

<p>
    Therefore, we can modify the class definition to
</p>
<?php code("class Triangle{
  private:
    int base;
    int height;
  public:
    //class constructor
    Triangle();

    //class method declaration
    void set_base(int);
    int get_base();
    double area ();
};");?>

<p>
    And we can have the definition of the Triangle() constructor by using the scope resolution operator (::)
</p>
<?php code("class Triangle{
  private:
    int base;
    int height;
  public:
    //class constructor
    Triangle();

    //class method declaration
    void set_values (int,int);
    double area ();
};

Triangle::Triangle(){
    base = 10;
    height = 20;
}
");?>

<p>
    For example:
</p>
<?php code('#include <iostream>
#include <string>

using namespace std;

class Triangle{
  private:
    int base;
    int height;
  public:
    //Constructor declaration
    Triangle();
    double area () {return (base*height)/2;}
};

//constructor definition
Triangle::Triangle(){
    base = 10;
    height = 50;
}

int main()
{
   Triangle triA;//uses the Triangle() constructor that assigns 10 and 50 to  data members base and height  
   cout << "triA area: " << triA.area() << endl;
  return 0;
}

');?>
<i><?php code('Note:  The constructor Triangle(), notice that it is the same name as the class name, is defined outside the Triangle class there it must use the scope resolution operator ::.');?></i>
<p>
    `
</p>
<p>
    Note also that if we declare a constructor that has one or more arguments (as the
    <tt>
        Triangle()
    </tt>
    constructor with three arguments) the default no-argument constructor is no longer available to the program. In this case, every object that is declared
    must be initialized.
</p>
<p>
    <br/>
    This constructor function is declared just like a regular member function, but with a name that matches the class name and without any return type; not
    even <code>void</code>.
</p>
</div>
<p class="mL10">
    <strong>5.3.8. Constructor Overloading</strong>
</p>
<div class="mL15">
<p>
    In the previous topic, we used a no-argument constructor, the Triangle(), in the definition of the
    <tt>
        Triangle
    </tt>
    class. We now discuss using multiple constructors in a class,
</p>
<p>
    <a name="ch11lev2sec11"></a>
    C++ allows you to define several constructors for a class. This is called <a name="ch11term22"></a><strong>function overloading.</strong> Overloading
    allows us to have constructors for different sets of circumstances.
</p>
<p>
    In
    <tt>
        Triangle class
    </tt>
    , we have a constructor that automatically assigns 10 to base and 50 to height, which are data members of the class.
</p>
<p>
    We might also want a constructor that allows us to create a Triangle by giving only the base, with the height being assigned default values of 100. We
    might also want a constructor that allows us to create a Triangle by giving both the base and height. You must declare all three constructors in the class
    definition as follows.
</p>
<?php code('class Triangle
{
  .
  .
  .
  public:
    Triangle(); //no argument, will give default value for base and height
    Triangle(int);//argument represents the base and height has a default value of 100
    Triangle(int, int); //arguemnts represents base and height respectively
  .
  .
  .
};
');?>
<p>
    <a name="iddle1337"></a>
    <a name="iddle1335"></a>
    <a name="iddle1071"></a>
    The constructor is now overloaded because we have three different constructors depending on the number of arguments given in a
    <tt>
        Triangle
    </tt>
    object declaration. The three constructor definitions follow.
</p>
<div class="row">
    <div class="col-xs-7">
    <?php code('#include <iostream>
    #include <string>

    using namespace std;

    class Triangle{
      private:
        int base;
        int height;
      public:
        //Constructor declaration
        Triangle();
        Triangle(int);
        Triangle(int, int);

        double area () {return (base*height)/2;}
    };
    //constructor method definition no-argument
    Triangle::Triangle () {
      base = 50;
      height = 100;
    }

    //overload constructor method single argument
    Triangle::Triangle (int x) {
      base = 20;
      height = x;
    }

    //overload constructor method two argument
    Triangle::Triangle (int x, int y) {
      base = x;
      height = y;
    }

    int main()
    {
       Triangle triA;  
       Triangle triB(5);
       Triangle triC(13,27);
       cout << "triA area: " << triA.area() << endl;
       cout << "triB area: " << triB.area() << endl;
       cout << "triC area: " << triC.area() << endl;
       
       return 0;
    }

    ');?>
    </div>
    <div class="col-xs-5">
    <?php code('triA area: 2500
triB area: 50
triC area: 175
');?>
    </div>
</div>
<p>
    With the given example above, the C++ compiler distinguishes among the three constructors by the number and type of arguments provided in the declaration
    of an object. With this we created three Triangle objects namely triA, triB and triC as in
</p>
<?php code('Triangle triA;  
Triangle triB(5);
Triangle triC(13,27);
');?>
<p>
    With this, the first declaration uses a no-argument constructor and creates the Triangle triA with a default base of 50 and default height of 100. The
    second declaration creates the Triangle triB with a default base of 20 and a height of 5. The third declaration creates the Triangle triC with a base of 13
    and height of 27.
</p>
<p>
    <strong>A complete class example with data members, default constructor, single and two argument constructor.</strong>
</p>
<div class="row">
    <div class="col-xs-7">
        <?php code('Program Code');?>
        <?php code('#include <iostream>
using namespace std; 
class Triangle{
  private: //optional since this is the default
    int base;
    int height;
  public:
    //class method declaration
    void set_values (int,int); 

    //class method declaration and definition
    //for area()
    double area() {return (base*height)/2;}
};

//class method definition for set_value()
void Triangle::set_values (int x, int y) {
  base = x;
  height = y;
}

int main(){
   Triangle triB;  
   triA.set_values(2,5);
   triB.set_values(5,10);
   cout << "triA area: " << triA.area() << endl;
  cout << "triB area: " << triB.area() << endl;
  return 0;
}
');?>
    </div>
    <div class="col-xs-5">
        <?php code('Output');?>
        <?php code('triA area : 5
triB area : 25
');?>

    </div>
    <div class="col-xs-12">
        <p><b>NOTE:</b> Notice that we use the object triA inside the main() even though it is not instantiated inside the main(). Remember that in the syntax of defining a class, <object_names> is an optional list of names for object.  In this example, we define the class and instantiated one object for the class named triA.  Therefore, object triA can be used anywhere in the main() since it is already created.</p>
    </div>
    <div class="col-xs-7">
        <?php code('Program Code');?>
        <?php code('#include <iostream>
#include <string>
using namespace std; 
class Triangle{
  private:
    int base;
    int height;
  public:
    //constructor method declaration
    Triangle();

    //overloaded constructor method declaration
    Triangle(int);    
    Triangle(int, int);

    //class method declaration and definition
    //for area()
    void set_base(int);
    void set_height(int);
    int get_base();
    int get_height();
    double area() {return (base*height)/2;}
}triA;

//constructor method definition 
Triangle::Triangle () {
  base = 50;
  height = 100;
}

//overload contructor method single argument
Triangle::Triangle (int x) {
  base = 20;
  height = x;
}

//overload contructor method two argument
Triangle::Triangle (int x, int y) {
  base = x;
  height = y;
}

//class method set_base()
void Triangle::set_base(int b){
    base = b;
}

//class method get_base()
int Triangle::get_base(){
    return base;
}

//class method set_height()
void Triangle::set_height(int h){
    height = h;
}


//class method get_height()
int Triangle::get_height(){
    return height;
}



int main(){
   Triangle triB;  
   Triangle triC(5);
   Triangle triD(10,20);

   //override the value of base and height in Triangle() constructor
   triA.set_base(1);
   triA.set_height(5);
');?>
    </div>
    <div class="col-xs-5">
        <?php code('Output');?>
        <?php code('triA area: 2
triB area: 2500
triC area: 50
triD area: 100
');?>

    </div>
</div>
<p align="center">
    Parts of a programmer-defined classes and objects
</p>
<p align="center">
   <img src="../uploads/images/c5-3/classes.png">
</p>
</div>